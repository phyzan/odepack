import numpy as np
from typing import Callable, Iterable, overload, Any

Func = Callable[[float, np.ndarray], np.ndarray] #f(t, q, *args) -> q
ObjFunc = Callable[[float, np.ndarray], float] #  f(t, q, *args) -> float
BoolFunc = Callable[[float, np.ndarray], bool] #  f(t, q, *args) -> bool


class Event:

    def __init__(self, name: str, when: ObjFunc, check_if: BoolFunc=None, mask: Func=None, hide_mask=False, event_tol=1e-12):...

    @property
    def name(self)->str:...
    
    @property
    def mask(self)->Func:...

    @property
    def hide_mask(self)->BoolFunc:...

    @property
    def when(self)->ObjFunc:...

    @property
    def check_if(self)->BoolFunc:...


class PeriodicEvent(Event):

    def __init__(self, name: str, period: float, start=0., mask: Func=None, hide_mask=False):...

    @property
    def period(self)->float:...

    @property
    def start(self)->float:...


class OdeResult:

    @property
    def t(self)->np.ndarray:...

    @property
    def q(self)->np.ndarray:...

    @property
    def event_map(self)->dict[str, np.ndarray]:...

    @property
    def diverges(self)->bool:...

    @property
    def success(self)->bool:...

    @property
    def runtime(self)->float:...

    @property
    def message(self)->str:...

    def examine(self):...

    def event_data(self, event: str)->tuple[np.ndarray, np.ndarray]:...


class SolverState:

    @property
    def t(self)->float:...

    @property
    def q(self)->np.ndarray:...

    @property
    def event(self)->str:...

    @property
    def diverges(self)->bool:...

    @property
    def is_running(self)->bool:...

    @property
    def is_dead(self)->bool:...

    @property
    def N(self)->int:...

    @property
    def message(self)->str:...

    def show(self):...


class LowLevelEventArray:

    def __init__(self, pointer, q_size: int, args_size: int):...


class LowLevelFunction:

    def __init__(self, pointer, q_size: int, args_size: int):...

    def __call__(self, t: float, q: np.ndarray, *args: float)->np.ndarray: ...


class LowLevelODE:

    @overload
    def __init__(self, f: LowLevelFunction, t0: float, q0: np.ndarray, *, rtol=1e-6, atol=1e-12, min_step=0., max_step=np.inf, first_step=0., args=(), method="RK45", events: LowLevelEventArray=None, save_dir="", save_events_only=False):...

    @overload
    def __init__(self, f : Callable[[float, np.ndarray, *tuple[Any, ...]], np.ndarray], t0: float, q0: np.ndarray, *, rtol=1e-6, atol=1e-12, min_step=0., max_step=np.inf, first_step=0., args=(), method="RK45", events: list[Event]=None, mask=None, save_dir="", save_events_only=False):...

    def integrate(self, interval, *, max_frames=-1, event_options: dict[str, tuple[int, bool]|int]={}, max_prints=0, include_first=False)->OdeResult:...

    def go_to(self, t, *, max_frames=-1, event_options: dict[str, tuple[int, bool]|int]={}, max_prints=0, include_first=False)->OdeResult:...

    def advance(self)->bool:...

    def state(self)->SolverState:...

    def copy(self)->LowLevelODE:...

    def save_data(self, save_dir: str):...

    def clear(self):...

    def event_data(self, event: str)->tuple[np.ndarray, np.ndarray]:...

    @property
    def dim(self)->int:...

    @property
    def t(self)->np.ndarray:...

    @property
    def q(self)->np.ndarray:...

    @property
    def event_map(self)->dict[str, np.ndarray]:...

    @property
    def solver_filename(self)->str:...

    @property
    def runtime(self)->float:...

    @property
    def diverges(self)->bool:...

    @property
    def is_dead(self)->float:...


class VariationalLowLevelODE(LowLevelODE):

    @overload
    def __init__(self, f: LowLevelFunction, t0: float, q0: np.ndarray, period: float, *, rtol=1e-6, atol=1e-12, min_step=0., max_step=np.inf, first_step=0., args=(), method="RK45", events: LowLevelEventArray=None, save_dir="", save_events_only=False):...

    @overload
    def __init__(self, f : Callable[[float, np.ndarray, *tuple[Any, ...]], np.ndarray], t0: float, q0: np.ndarray, period: float, *, rtol=1e-6, atol=1e-12, min_step=0., max_step=np.inf, first_step=0., args=(), method="RK45", events: list[Event]=None, mask=None, save_dir="", save_events_only=False):...

    def var_integrate(self, interval: float, lyap_period: float, max_prints=0)->OdeResult:...

    @property
    def t_lyap(self)->np.ndarray:...

    @property
    def lyap(self)->np.ndarray:...

    def copy(self)->VariationalLowLevelODE:...


def integrate_all(ode_array: Iterable[LowLevelODE], interval, max_frames=-1, event_options: dict[str, tuple[int, bool]|int]={}, threads=-1, display_progress=False):...

def var_integrate_all(varode_array: Iterable[VariationalLowLevelODE], interval: float, lyap_period: float, threads=-1, display_progress=False):...